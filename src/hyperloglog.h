   /* HyperLogLog Implementation

   An implementation of the HyperLogLog algorithm of Flajolet, Fusy, Gandouet,
   and Meunier for estimating cardinalities of sets using only a small, fixed 
   amount of memory.

   The idea of the algorithm is to hash each member of the set and keep track
   of the maximum number of leading zeros we've seen in any hashed value.
   This statistic lets you roughly estimate the size of the underlying set
   because if the bits generated by the hash function are independent, seeing
   exactly N leading zeros in a hashed value should happen once in every
   2^(N+1) distinct elements.

   In practice, the scheme described above would give an unacceptably large 
   variance, so HyperLogLog uses a technique called stochastic averaging 
   (previously developed by Flajolet and Martin) to bring the variance down by
   keeping 2^B statistics instead of just 1. B bits of the hashed value are
   extracted and used to select a counter and the remaining bits of the hash
   function are examined for leading zeros as described above. When these 2^B
   counters are suitably combined, they can give a much more stable estimate
   of the cardinality of the underlying set. HyperLogLog also uses an estimate 
   given by the analysis of a random balls-in-bins model when less than 2^B 
   counters have been initialized, which makes the estimates very good when the
   sets are still small.

   You need 2^B bytes to store a HyperLogLog sketch: one byte to store the 
   maximum number of leading zeros you've seen in each of the 2^B hash 
   functions. From this representation, you get an expected relative error of
   1.04/sqrt(2^B), which is about 2% error when using 2KB of storage. Our
   implementation adds some additional memory overhead to support AOF rewrites.
   In particular, we store the set member which hashed to the value with the
   maximum number of leading zeros for each of the 2^B buckets. This lets us
   recreate any HyperLogLog sketch with at most 2^B KADD commands when an AOF
   rewrite is requested.

   HyperLogLog counters can be efficiently combined to compute estimates of 
   the union and intersection of sets. Obtaining a union estimate is 
   straightforward, since taking the pairwise max of each of the 2^B leading
   zero counts creates the HyperLogLog sketch that would have been created by
   the union of the adds to both sets. Intersections can't be estimated as
   directly, but the inclusion-exclusion principle lets us estimate them
   using an alternating sum of sums of union cardinalities. In the case of 
   unions, the expected relative error remains 1.04/sqrt(2^B), applied to the
   size of the actual union. In the case of intersections, a good bound on the
   relative error is unknown, but the absolute error tends to be no more than 
   1.04/sqrt(2^B) * (size of union) in practice, which means that the results 
   are only far off for large sets with small intersections, and even then the 
   error is still reasonable with respect to the size of the underlying sets.
   */

#ifndef __HYPERLOGLOG_H
#define __HYPERLOGLOG_H
#include <stdint.h>

#define HLL_B 11
#define HLL_M (1 << HLL_B)
#define HLL_HASH_BITS (32 - HLL_B)
#define HLL_ALPHA (0.7213/(1 + 1.079/(1 << HLL_B)))

typedef struct hyperloglog {
    int8_t counters[HLL_M];
    void *maxHashes[HLL_M];
} hyperloglog;

hyperloglog *hyperloglogNew(void);
uint64_t hyperloglogCard(hyperloglog *hll);
int hyperloglogAdd(hyperloglog *hll, const unsigned char *value, int len);

#endif // __HYPERLOGLOG_H
